/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package ohos.data.relational_store

import ohos.ffi.{RemoteDataLite, releaseFFIData, Callback0Param}
import std.collection.{HashMap, ArrayList}
import std.sync.Mutex
import ohos.labels.APILevel
import ohos.callback_invoke.{Callback0Argument, CallbackObject}
import ohos.business_exception.{ BusinessException, ERR_PARAMETER_ERROR }

/**
 * Provides methods for managing the relational database (RDB).
 * This class provides methods for creating, querying, updating, and deleting RDBs.
 */
@!APILevel[
    since: "22",
    syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
]
public class RdbStore <: RemoteDataLite {
    let eventCallbackMaps = HashMap<String, ArrayList<(CallbackObject, Int64)>>()
    let observers_ = ArrayList<(CallbackObject, Int64)>()
    let syncObservers_ = ArrayList<(CallbackObject, Int64)>()
    let onOffMutex = Mutex()
    var versionValue: Int32 = 0

    init(id: Int64) {
        super(id)
    }

    ~init() {
        releaseFFIData(myDataId)
    }

    /**
     * Queries data in the database based on specified conditions.
     *
     * @param { RdbPredicates } predicates - The specified query condition by the instance object of RdbPredicates.
     * @param { Array<String> } [columns] - The columns to query. If the value is null, the query applies to all columns.
     * @returns { ResultSet } Return the ResultSet object if the operation is successful.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func query(predicates: RdbPredicates, columns!: Array<String> = []): ResultSet {
        var errCode: Int32 = 0
        let columnsSize = columns.size
        var columnsArray: CPointer<CString> = CPointer<CString>()
        if (columnsSize > 0) {
            columnsArray = unsafe { LibC.malloc<CString>(count: columnsSize) }
            throwIfOOM(columnsArray.isNull(), "RdbStore", "query")
        }
        for (i in 0..columnsSize) {
            unsafe {
                try {
                    columnsArray.write(i, LibC.mallocCString(columns[i]))
                } catch (_: Exception) {
                    freeCStringArray(columnsArray, i)
                    LibC.free<CString>(columnsArray)
                    RELATIONAL_STORE_LOG.error("RdbStore query failed: ${getErrorMsg(MEMORY_ERROR)}")
                    throw BusinessException(getErrorCode(MEMORY_ERROR),
                        "RdbStore query failed: ${getErrorMsg(MEMORY_ERROR)}")
                }
            }
        }

        var id: Int64
        unsafe {
            id = FfiOHOSRelationalStoreQuery(getID(), predicates.getID(), columnsArray, columnsSize, inout errCode)
        }
        for (i in 0..columnsSize) {
            unsafe { LibC.free(columnsArray.read(i)) }
        }
        unsafe { LibC.free<CString>(columnsArray) }
        throwIfNotSuccess(errCode, "RdbStore", "query")
        return ResultSet(id)
    }

    /**
     * Deletes data from the database based on a specified instance object of RdbPredicates.
     *
     * @param { RdbPredicates } predicates - The specified delete condition by the instance object of RdbPredicates.
     * @returns { Int64 } Return the number of affected rows.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     * @throws { BusinessException  } 14800047 - The WAL file size exceeds the default limit.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func delete(predicates: RdbPredicates): Int64 {
        var num: Int64
        unsafe {
            var errCode: Int32 = 0
            num = FfiOHOSRelationalStoreDelete(getID(), predicates.getID(), inout errCode)
            throwIfNotSuccess(errCode, "RdbStore", "delete")
        }
        return num
    }

    /**
     * Backs up a database in a specified name.
     *
     * @param { String } destName - Indicates the name that saves the database backup.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func backup(destName: String): Unit {
        unsafe {
            if (destName.isEmpty()) {
                RELATIONAL_STORE_LOG.error("RdbStore backup failed: ${paramError("destName", "not empty string")}")
                throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                    "RdbStore backup failed: ${paramError("destName", "not empty string")}")
            }
            let cDestName: CString = LibC.mallocCString(destName)
            let code = FfiOHOSRelationalStoreBackUp(getID(), cDestName)
            LibC.free(cDestName)
            throwIfNotSuccess(code, "RdbStore", "backup")
        }
    }

    /**
     * Restores a database from a specified database file.
     *
     * @param { String } srcName - Indicates the name that saves the database file.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func restore(srcName: String): Unit {
        unsafe {
            if (srcName.isEmpty()) {
                RELATIONAL_STORE_LOG.error("RdbStore restore failed: ${paramError("srcName", "not empty string")}")
                throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                    "RdbStore restore failed: ${paramError("srcName", "not empty string")}")
            }
            let cSrcName: CString = LibC.mallocCString(srcName)
            let code = FfiOHOSRelationalStoreReStore(getID(), cSrcName)
            LibC.free(cSrcName)
            throwIfNotSuccess(code, "RdbStore", "restore")
        }
    }

    /**
     * Commit the the sql you have executed.
     *
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func commit(): Unit {
        let code = unsafe { FfiOHOSRelationalStoreCommit(getID()) }
        throwIfNotSuccess(code, "RdbStore", "commit")
    }

    /**
     * Roll back the sql you have already executed.
     *
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func rollBack(): Unit {
        let code = unsafe { FfiOHOSRelationalStoreRollBack(getID()) }
        throwIfNotSuccess(code, "RdbStore", "rollBack")
    }

    /**
     * BeginTransaction before execute your sql.
     *
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     * @throws { BusinessException  } 14800047 - The WAL file size exceeds the default limit.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func beginTransaction(): Unit {
        let code = unsafe { FfiOHOSRelationalStoreBeginTransaction(getID()) }
        throwIfNotSuccess(code, "RdbStore", "beginTransaction")
    }

    func executeSqlImpl(sql: String): Unit {
        unsafe {
            if (sql.isEmpty()) {
                RELATIONAL_STORE_LOG.error("RdbStore executeSql failed: ${paramError("sql", "not empty string")}")
                throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                    "RdbStore executeSql failed: ${paramError("sql", "not empty string")}")
            }
            let cSql: CString = LibC.mallocCString(sql)
            var errCode: Int32 = 0
            FfiOHOSRelationalStoreExecuteSql(getID(), cSql, inout errCode)
            LibC.free(cSql)
            throwIfNotSuccess(errCode, "RdbStore", "beginTransaction")
        }
    }

    /**
     * Inserts a row of data into the target table.
     *
     * @param { String } table - Indicates the row of data to be inserted into the table.
     * @param { ValuesBucket } values - Indicates the row of data ValuesBucket to be inserted into the table.
     * @param { ConflictResolution } conflict - Indicates the ConflictResolution to insert data into the table.
     * @returns { Int64 } Return the row ID if the operation is successful. return -1 otherwise.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     * @throws { BusinessException  } 14800047 - The WAL file size exceeds the default limit.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func insert(table: String, values: ValuesBucket,
        conflict!: ConflictResolution = ConflictResolution.OnConflictNone): Int64 {
        if (table.isEmpty()) {
            RELATIONAL_STORE_LOG.error("RdbStore insert failed: ${paramError("table", "not empty string")}")
            throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                "RdbStore insert failed: ${paramError("table", "not empty string")}")
        }
        let cTable = unsafe { LibC.mallocCString(table) }
        let cValue = CValuesBucket.create(values)
        var errCode: Int32 = 0
        throwIfOOM(cValue.isNone(), "RdbStore", "insert") {
            unsafe { LibC.free(cTable) }
        }
        let result = unsafe {
            FfiOHOSRelationalStoreInsert(getID(), cTable, cValue.getOrThrow(), conflict.getValue(), inout errCode)
        }
        unsafe {
            LibC.free(cTable)
            cValue.getOrThrow().free()
            throwIfNotSuccess(errCode, "RdbStore", "insert")
        }
        return result
    }

    /**
     * Updates data in the database based on a specified instance object of RdbPredicates.
     *
     * @param { ValuesBucket } values - Indicates the row of data to be updated in the database.
     * The key-value pairs are associated with column names of the database table.
     * @param { RdbPredicates } predicates - Indicates the specified update condition by the instance object of RdbPredicates.
     * @param { ConflictResolution } conflict - Indicates the ConflictResolution to update data into the table.
     * @returns { Int64 } Return the number of affected rows.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     * @throws { BusinessException  } 14800047 - The WAL file size exceeds the default limit.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func update(values: ValuesBucket, predicates: RdbPredicates,
        conflict!: ConflictResolution = ConflictResolution.OnConflictNone): Int64 {
        let cValueBucket = CValuesBucket.create(values)
        var errCode: Int32 = 0
        throwIfOOM(cValueBucket.isNone(), "RdbStore", "update")
        let affectedRows = unsafe {
            FfiOHOSRelationalStoreUpdate(getID(), cValueBucket.getOrThrow(), predicates.getID(), conflict.getValue(),
                inout errCode)
        }
        unsafe {
            cValueBucket.getOrThrow().free()
            throwIfNotSuccess(errCode, "RdbStore", "update")
        }
        return affectedRows
    }

    /**
     * Inserts a batch of data into the target table.
     *
     * @param { String } table - Indicates the target table.
     * @param { Array<ValuesBucket> } values - Indicates the rows of data ValuesBucket to be inserted into the table.
     * @returns { Int64 } Return the number of values that were inserted if the operation is successful. returns -1 otherwise.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     * @throws { BusinessException  } 14800047 - The WAL file size exceeds the default limit.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func batchInsert(table: String, values: Array<ValuesBucket>): Int64 {
        unsafe {
            if (table.isEmpty()) {
                RELATIONAL_STORE_LOG.error("RdbStore batchInsert failed: ${paramError("table", "not empty string")}")
                throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                    "RdbStore batchInsert failed: ${paramError("table", "not empty string")}")
            }
            let valuesSize = values.size
            if (valuesSize == 0) {
                return 0
            }
            let valuesBucketArray: CPointer<CValuesBucket> = calloc<CValuesBucket>(count: valuesSize)
            throwIfOOM(valuesBucketArray.isNull(), "RdbStore", "batchInsert")
            for (i in 0..valuesSize) {
                let cVlaueBucket = CValuesBucket.create(values[i])
                throwIfOOM(cVlaueBucket.isNone(), "RdbStore", "batchInsert") {
                    freeValuesBucketArray(valuesBucketArray, i)
                    LibC.free(valuesBucketArray)
                }
                valuesBucketArray.write(i, cVlaueBucket.getOrThrow())
            }
            let tableNameC = mallocCString(table)
            var insertNum: Int64 = 0
            throwIfOOM(tableNameC.isNone(), "RdbStore", "batchInsert") {
                for (i in 0..valuesSize) {
                    valuesBucketArray.read(i).free()
                }
                LibC.free(valuesBucketArray)
            }
            let rtnCode = FfiOHOSRelationalStoreBatchInsert(getID(), tableNameC.getOrThrow(), valuesBucketArray,
                valuesSize, inout insertNum)
            LibC.free(tableNameC.getOrThrow())
            for (i in 0..valuesSize) {
                valuesBucketArray.read(i).free()
            }
            LibC.free(valuesBucketArray)
            throwIfNotSuccess(rtnCode, "RdbStore", "batchInsert")
            return insertNum
        }
    }

    /**
     * Queries data in the database based on SQL statement.
     *
     * @param { String } sql - Indicates the SQL statement to execute.
     * @param { Array<RelationalStoreValueType> } [bindArgs] - Indicates the ValueType values of the parameters in the SQL statement. The values are strings.
     * @returns { ResultSet } Return the ResultSet object if the operation is successful.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func querySql(sql: String, bindArgs!: Array<RelationalStoreValueType> = []): ResultSet {
        unsafe {
            if (sql.isEmpty()) {
                RELATIONAL_STORE_LOG.error("RdbStore querySql failed: ${paramError("sql", "not empty string")}")
                throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                    "RdbStore querySql failed: ${paramError("sql", "not empty string")}")
            }
            let size = bindArgs.size
            let cSql = LibC.mallocCString(sql)
            var errCode: Int32 = 0
            let cBindArgs = if (size != 0) {
                LibC.malloc<RetValueType>(count: size)
            } else {
                CPointer<RetValueType>()
            }
            throwIfOOM(cBindArgs.isNull() && size != 0, "RdbStore", "querySql") {
                LibC.free(cSql)
            }
            for (i in 0..size) {
                let arg = RetValueType.create(bindArgs[i])
                throwIfOOM(arg.isNone(), "RdbStore", "querySql") {
                    LibC.free(cSql)
                    freeValuesArray(cBindArgs, i)
                    LibC.free<RetValueType>(cBindArgs)
                }
                cBindArgs.write(i, arg.getOrThrow())
            }
            let id = FfiOHOSRelationalStoreQuerySql(getID(), cSql, cBindArgs, size, inout errCode)
            for (i in 0..size) {
                cBindArgs.read(i).free()
            }
            LibC.free(cBindArgs)
            LibC.free(cSql)
            throwIfNotSuccess(errCode, "RdbStore", "querySql")
            return ResultSet(id)
        }
    }

    /**
     * Executes a SQL statement that contains specified parameters but returns no value.
     *
     * @param { String } sql - Indicates the SQL statement to execute.
     * @param { Array<RelationalStoreValueType> } [bindArgs] - Indicates the ValueType values of the parameters in the SQL statement. The values are strings.
     * @throws { BusinessException  } 801 - Capability not supported the sql(attach,begin,commit,rollback etc.).
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800015 - The database does not respond.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     * @throws { BusinessException  } 14800047 - The WAL file size exceeds the default limit.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true,
        workerthread: true
    ]
    public func executeSql(sql: String, bindArgs!: Array<RelationalStoreValueType> = []): Unit {
        if (bindArgs.size == 0) {
            executeSqlImpl(sql)
        } else {
            executeSqlImpl(sql, bindArgs)
        }
    }

    func executeSqlImpl(sql: String, bindArgs: Array<RelationalStoreValueType>): Unit {
        unsafe {
            if (sql.isEmpty()) {
                RELATIONAL_STORE_LOG.error("RdbStore executeSql failed: ${paramError("sql", "not empty string")}")
                throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                    "RdbStore executeSql failed: ${paramError("sql", "not empty string")}")
            }
            let cSql: CString = LibC.mallocCString(sql)
            var errCode: Int32 = 0
            let size = bindArgs.size
            let cBindArgs: CPointer<RetValueType> = if (size != 0) {
                LibC.malloc<RetValueType>(count: size)
            } else {
                CPointer<RetValueType>()
            }
            throwIfOOM(cBindArgs.isNull() && size != 0, "RdbStore", "executeSql") {
                LibC.free(cSql)
            }
            for (i in 0..size) {
                let arg = RetValueType.create(bindArgs[i])
                throwIfOOM(arg.isNone(), "RdbStore", "executeSql") {
                    LibC.free(cSql)
                    freeValuesArray(cBindArgs, i)
                    LibC.free<RetValueType>(cBindArgs)
                }
                cBindArgs.write(i, arg.getOrThrow())
            }

            FfiOHOSRelationalStoreExecuteSqlBindArgs(getID(), cSql, cBindArgs, size, inout errCode)
            for (i in 0..size) {
                cBindArgs.read(i).free()
            }
            LibC.free<RetValueType>(cBindArgs)
            LibC.free(cSql)
            throwIfNotSuccess(errCode, "RdbStore", "executeSql")
        }
    }

    func findCallbackObject(list: ArrayList<(CallbackObject, Int64)>, callback: CallbackObject): Bool {
        for (item in list) {
            if (refEq(callback, item[0])) {
                return true
            }
        }
        false
    }

    /**
     * Registers an observer for the database.
     *
     * @param { String } event - Event type, which must match the event type in emit.
     * @param { Bool } interProcess - Indicates whether it is an interprocess subscription or an in-process subscription.
     * @param { Callback0Argument } observer - The observer of data change events in the database.
     * @throws { BusinessException  } 801 - Capability not supported.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800050 - Failed to obtain the subscription service.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func on(event: String, interProcess: Bool, observer: Callback0Argument): Unit {
        if (event.isEmpty()) {
            RELATIONAL_STORE_LOG.error("RdbStore on failed: ${paramError("event", "not empty string")}")
            throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                "RdbStore on failed: ${paramError("event", "not empty string")}")
        }
        var v = eventCallbackMaps.entryView(event)
        let callbackList = if (v.value.isNone()) {
            let list = ArrayList<(CallbackObject, Int64)>()
            eventCallbackMaps.add(event, list)
            list
        } else {
            v.value.getOrThrow()
        }
        if (findCallbackObject(callbackList, observer)) {
            RELATIONAL_STORE_LOG.error("RdbStore on failed: ${paramError("callback object", "different")}")
            return
        }
        unsafe {
            let wrapper = {=> observer.invoke(None)}
            let lambdaData = Callback0Param<Unit>(wrapper)
            let cEvent = LibC.mallocCString(event)
            let errCode = FfiOHOSRelationalStoreOn(
                getID(),
                cEvent,
                interProcess,
                lambdaData.getID(),
                lambdaData.getID()
            )
            LibC.free(cEvent)
            throwIfNotSuccess(errCode, "RdbStore", "on")
            callbackList.add((observer, lambdaData.getID()))
        }
    }

    /**
     * Remove specified observer of specified type from the database.
     *
     * @param { String } event - Indicates the subscription event.
     * @param { Bool } interProcess - Indicates whether it is an interprocess subscription or an in-process subscription.
     * @param { ?Callback0Argument } [observer] - The data change observer already registered.
     * @throws { BusinessException  } 801 - Capability not supported.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800050 - Failed to obtain the subscription service.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func off(event: String, interProcess: Bool, observer!: ?Callback0Argument = None): Unit {
        if (let Some(v) <- observer) {
            offImpl(event, interProcess, v)
        } else {
            offImpl(event, interProcess)
        }
    }

    func offImpl(event: String, interProcess: Bool): Unit {
        var v = eventCallbackMaps.entryView(event)
        if (v.value.isNone() || v.value.getOrThrow().size == 0) {
            RELATIONAL_STORE_LOG.error("RdbStore on failed: The event is not registered")
            return
        }
        unsafe {
            let cEvent = LibC.mallocCString(event)
            let errCode = FfiOHOSRelationalStoreOffAll(getID(), cEvent, interProcess)
            LibC.free(cEvent)
            throwIfNotSuccess(errCode, "RdbStore", "off")
            v.value.getOrThrow().clear()
        }
    }

    func offImpl(event: String, interProcess: Bool, callback: Callback0Argument): Unit {
        var v = eventCallbackMaps.entryView(event)
        if (v.value.isNone() || v.value.getOrThrow().size == 0) {
            RELATIONAL_STORE_LOG.error("RdbStore on failed: The event is not registered")
            return
        }
        unsafe {
            v.value.getOrThrow().removeIf(
                {
                    item =>
                    if (refEq(item[0], callback)) {
                        let cEvent = LibC.mallocCString(event)
                        let errCode = FfiOHOSRelationalStoreOff(getID(), cEvent, interProcess, item[1])
                        LibC.free(cEvent)
                        throwIfNotSuccess(errCode, "RdbStore", "off")
                        return true
                    }
                    return false
                }
            )
        }
    }

    func offDataChangeCommon(`type`: SubscribeType, callback: CallbackObject): Unit {
        synchronized(onOffMutex) {
            let callbackList = observers_
            if (callbackList.size == 0) {
                RELATIONAL_STORE_LOG.error("RdbStore off failed: The event is not registered")
                return
            }
            unsafe {
                callbackList.removeIf(
                    {
                        item =>
                        if (refEq(item[0], callback)) {
                            let errCode = FfiOHOSRelationalStoreOffArrStrChangeInfo(getID(), `type`.getValue(), item[1])
                            throwIfNotSuccess(errCode, "RdbStore", "offDataChange")
                            return true
                        }
                        return false
                    }
                )
            }
        }
    }

    /**
     * Notifies the registered observers of a change to the data resource specified by Uri.
     *
     * @param { String } event - Indicates the subscription event.
     * @throws { BusinessException  } 801 - Capability not supported.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800050 - Failed to obtain the subscription service.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func emit(event: String): Unit {
        unsafe {
            let cEvent = LibC.mallocCString(event)
            let errCode = FfiOHOSRelationalStoreEmit(getID(), cEvent)
            LibC.free(cEvent)
            throwIfNotSuccess(errCode, "RdbStore", "emit")
        }
    }
}