/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package ohos.data.relational_store

import ohos.labels.APILevel
import ohos.ffi.{RemoteDataLite, releaseFFIData, CArrString}
import ohos.business_exception.{ BusinessException, ERR_PARAMETER_ERROR }

/**
 * Provides methods for accessing a database result set generated by querying the database.
 */
@!APILevel[
    since: "22",
    syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
]
public class ResultSet <: RemoteDataLite {
    init(id: Int64) {
        super(id)
    }

    ~init() {
        releaseFFIData(myDataId)
    }

    /**
     * Obtains the names of all columns in a result set.
     * The column names are returned as a string array, in which the strings are in the same order
     * as the columns in the result set.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop columnNames: Array<String> {
        get() {
            var cArr: CArrString
            unsafe {
                cArr = FfiOHOSRelationalStoreGetAllColumnNames(getID())
            }
            var result = Array<String>()
            throwIfOOM(cArr.size == -1, "ResultSet", "get columnNames")
            if (cArr.head.isNotNull()) {
                let ptr = cArr.head
                let size = cArr.size
                result = unsafe { Array<String>(size, {i => ptr.read(i).toString()}) }
                for (i in 0..size) {
                    unsafe { LibC.free(ptr.read(i)) }
                }
                unsafe { LibC.free<CString>(ptr) }
            }
            return result
        }
    }

    /**
     * Obtains the number of columns in the result set.
     * The returned number is equal to the length of the string array returned by the
     * columnNames method.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop columnCount: Int32 {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let count = FfiOHOSRelationalStoreGetColumnCount(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get columnCount")
                return count
            }
        }
    }

    /**
     * Obtains the number of rows in the result set.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop rowCount: Int32 {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let count = FfiOHOSRelationalStoreGetRowCount(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get rowCount")
                return count
            }
        }
    }

    /**
     * Obtains the current index of the result set.
     * The result set index starts from 0.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop rowIndex: Int32 {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let count = FfiOHOSRelationalStoreGetRowIndex(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get rowIndex")
                return count
            }
        }
    }

    /**
     * Checks whether the cursor is positioned at the first row.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop isAtFirstRow: Bool {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let result = FfiOHOSRelationalStoreIsAtFirstRow(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get isAtFirstRow")
                return result
            }
        }
    }

    /**
     * Checks whether the cursor is positioned at the last row.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop isAtLastRow: Bool {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let result = FfiOHOSRelationalStoreIsAtLastRow(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get isAtLastRow")
                return result
            }
        }
    }

    /**
     * Checks whether the cursor is positioned after the last row.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop isEnded: Bool {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let result = FfiOHOSRelationalStoreIsEnded(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get isEnded")
                return result
            }
        }
    }

    /**
     * Checks whether the cursor is positioned before the first row.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop isStarted: Bool {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let result = FfiOHOSRelationalStoreIsStarted(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get isStarted")
                return result
            }
        }
    }

    /**
     * Checks whether the current result set is closed.
     * If the result set is closed by calling the close method, true will be returned.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core"
    ]
    public prop isClosed: Bool {
        get() {
            unsafe {
                var errCode: Int32 = 0
                let result = FfiOHOSRelationalStoreIsClosed(getID(), inout errCode)
                throwIfNotSuccess(errCode, "ResultSet", "get isClosed")
                return result
            }
        }
    }

    /**
     * Obtains the value of the specified column in the current row as double.
     * The implementation class determines whether to throw an exception if the value of the specified column
     * in the current row is null, the specified column is not of the double type.
     *
     * @param { Int32 } columnIndex - Indicates the specified column index, which starts from 0.
     * @returns { Float64 } The value of the specified column as a double.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getDouble(columnIndex: Int32): Float64 {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGetDouble(getID(), columnIndex, inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "getDouble")
            return result
        }
    }

    /**
     * Go to the specified row of the result set.
     *
     * @param { Int32 } position - Indicates the index of the specified row, which starts from 0.
     * @returns { Bool } True if the result set is moved successfully; Returns false otherwise.
     * @throws { BusinessException } 14800000 - Inner error.
     * @throws { BusinessException } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException } 14800029 - SQLite: The database is full.
     * @throws { BusinessException } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func goToRow(position: Int32): Bool {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGoToRow(getID(), position, inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "goToRow")
            return result
        }
    }

    /**
     * Go to the previous row of the result set.
     *
     * @returns { Bool } True if the result set is moved successfully;
     * Returns false otherwise, for example, if the result set is already in the first row.
     * @throws { BusinessException } 14800000 - Inner error.
     * @throws { BusinessException } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException } 14800029 - SQLite: The database is full.
     * @throws { BusinessException } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func goToPreviousRow(): Bool {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGoToPreviousRow(getID(), inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "goToPreviousRow")
            return result
        }
    }

    /**
     * Go to the last row of the result set.
     *
     * @returns { Bool } True if the result set is moved successfully;
     * Returns false otherwise, for example, if the result set is empty.
     * @throws { BusinessException } 14800000 - Inner error.
     * @throws { BusinessException } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException } 14800029 - SQLite: The database is full.
     * @throws { BusinessException } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func goToLastRow(): Bool {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGoToLastRow(getID(), inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "goToLastRow")
            return result
        }
    }

    /**
     * Obtains the column name based on the specified column index.
     * The column index is passed as an input parameter.
     *
     * @param { Int32 } columnIndex - Indicates the index of the specified column in the result set.
     * @returns { String } The name of the specified column.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getColumnName(columnIndex: Int32): String {
        unsafe {
            var errCode: Int32 = 0
            let name = FfiOHOSRelationalStoreGetColumnName(getID(), columnIndex, inout errCode)
            var result: String = ""
            if (!name.isNull()) {
                result = name.toString()
                LibC.free(name)
            }

            throwIfNotSuccess(errCode, "ResultSet", "getColumnName")
            return result
        }
    }

    /**
     * Checks whether the value of the specified column in the current row is null.
     *
     * @param { Int32 } columnIndex - Indicates the specified column index, which starts from 0.
     * @returns { Bool } True if the value of the specified column in the current row is null;
     * Returns false otherwise.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func isColumnNull(columnIndex: Int32): Bool {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreIsColumnNull(getID(), columnIndex, inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "isColumnNull")
            return result
        }
    }

    /**
     * Obtains the value of the specified column in the current row as an asset.
     * The implementation class determines whether to throw an exception if the value of the specified column
     * in the current row is null or the specified column is not of the Asset type.
     *
     * @param { Int32 } columnIndex - Indicates the specified column index, which starts from 0.
     * @returns { Asset } The value of the specified column as an asset.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getAsset(columnIndex: Int32): Asset {
        unsafe {
            var errCode: Int32 = 0
            let asset = FfiOHOSRelationalStoreGetAsset(getID(), columnIndex, inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "getAsset")

            var result: Asset
            try {
                result = convert(asset)
            } finally {
                LibC.free(asset.name)
                LibC.free(asset.uri)
                LibC.free(asset.path)
                LibC.free(asset.createTime)
                LibC.free(asset.modifyTime)
                LibC.free(asset.size)
            }

            return result
        }
    }

    /**
     * Closes the result set.
     * Calling this method on the result set will release all of its resources and makes it ineffective.
     *
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func close(): Unit {
        let rtnCode: Int32 = unsafe { FfiOHOSRelationalStoreClose(getID()) }
        throwIfNotSuccess(rtnCode, "ResultSet", "close")
    }

    /**
     * Obtains the column index based on the specified column name.
     * The column name is passed as an input parameter.
     *
     * @param { String } columnName - Indicates the name of the specified column in the result set.
     * @returns { Int32 } The index of the specified column.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getColumnIndex(columnName: String): Int32 {
        unsafe {
            if (columnName.isEmpty() || columnName.startsWith("\0")) {
                RELATIONAL_STORE_LOG.error(
                    "ResultSet getColumnIndex failed: ${paramError("columnName", "not empty string")}")
                throw BusinessException(getErrorCode(ERR_PARAMETER_ERROR),
                    "ResultSet getColumnIndex failed: ${paramError("columnName", "not empty string")}")
            }
            var errCode: Int32 = 0
            let cColumnName = mallocCString(columnName)
            throwIfOOM(cColumnName.isNone(), "ResultSet", "getColumnIndex")
            let result = FfiOHOSRelationalStoreGetColumnIndex(getID(), cColumnName.getOrThrow(), inout errCode)
            LibC.free(cColumnName.getOrThrow())
            throwIfNotSuccess(errCode, "ResultSet", "getColumnIndex")
            return result
        }
    }

    /**
     * Obtains the value of the specified column in the current row as string.
     * The implementation class determines whether to throw an exception if the value of the specified column
     * in the current row is null or the specified column is not of the string type.
     *
     * @param { Int32 } columnIndex - Indicates the specified column index, which starts from 0.
     * @returns { String } The value of the specified column as a string.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getString(columnIndex: Int32): String {
        unsafe {
            var errCode: Int32 = 0
            let str = FfiOHOSRelationalStoreGetString(getID(), columnIndex, inout errCode)
            let result = str.toString()
            LibC.free(str)
            throwIfNotSuccess(errCode, "ResultSet", "getString")
            return result
        }
    }

    /**
     * Go to the first row of the result set.
     *
     * @returns { Bool } True if the result set is moved successfully;
     * Returns false otherwise, for example, if the result set is empty.
     * @throws { BusinessException } 14800000 - Inner error.
     * @throws { BusinessException } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException } 14800029 - SQLite: The database is full.
     * @throws { BusinessException } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func goToFirstRow(): Bool {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGoToFirstRow(getID(), inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "goToFirstRow")
            return result
        }
    }

    /**
     * Obtains the value of the specified column in the current row as assets.
     * The implementation class determines whether to throw an exception if the value of the specified column
     * in the current row is null or the specified column is not of the Assets type.
     *
     * @param { Int32 } columnIndex - Indicates the specified column index, which starts from 0.
     * @returns { Assets } The value of the specified column as assets.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getAssets(columnIndex: Int32): Assets {
        unsafe {
            var errCode: Int32 = 0
            let assets = FfiOHOSRelationalStoreGetAssets(getID(), columnIndex, inout errCode)
            var result = Array<Asset>()
            if (assets.size == -1) {
                throw BusinessException(14800026, "Failed malloc in C code!")
            }
            if (assets.head.isNotNull()) {
                let ptr = assets.head
                let size = assets.size
                result = Array<Asset>(size, {i => convert(ptr.read(i))})
                for (i in 0..size) {
                    let data = ptr.read(i)
                    LibC.free(data.name)
                    LibC.free(data.uri)
                    LibC.free(data.path)
                    LibC.free(data.createTime)
                    LibC.free(data.modifyTime)
                    LibC.free(data.size)
                }
                LibC.free(ptr)
            }
            throwIfNotSuccess(errCode, "ResultSet", "getAssets")
            return result
        }
    }

    /**
     * Obtains the value of the specified column in the current row as long.
     * The implementation class determines whether to throw an exception if the value of the specified column
     * in the current row is null, the specified column is not of the integer type.
     *
     * @param { Int32 } columnIndex - Indicates the specified column index, which starts from 0.
     * @returns { Int64 } The value of the specified column as a long.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getLong(columnIndex: Int32): Int64 {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGetLong(getID(), columnIndex, inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "getLong")
            return result
        }
    }

    /**
     * Go to the next row of the result set.
     *
     * @returns { Bool } True if the result set is moved successfully;
     * Returns false otherwise, for example, if the result set is already in the last row.
     * @throws { BusinessException } 14800000 - Inner error.
     * @throws { BusinessException } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException } 14800029 - SQLite: The database is full.
     * @throws { BusinessException } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func goToNextRow(): Bool {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGoToNextRow(getID(), inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "goToNextRow")
            return result
        }
    }

    /**
     * Obtains the value of the specified column in the current row as a byte array.
     * The implementation class determines whether to throw an exception if the value of the specified column
     * in the current row is null or the specified column is not of the Blob type.
     *
     * @param { Int32 } columnIndex - Indicates the specified column index, which starts from 0.
     * @returns { Array<UInt8> } The value of the specified column as a byte array.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getBlob(columnIndex: Int32): Array<UInt8> {
        unsafe {
            var errCode: Int32 = 0
            let arr = FfiOHOSRelationalStoreGetBlob(getID(), columnIndex, inout errCode)
            var result = Array<UInt8>()
            if (arr.size == -1) {
                throw BusinessException(14800026, "Failed malloc in C code!")
            }
            if (arr.head.isNotNull()) {
                let ptr = arr.head
                let size = arr.size
                result = Array<UInt8>(size, {i => ptr.read(i)})
                LibC.free<UInt8>(ptr)
            }
            throwIfNotSuccess(errCode, "ResultSet", "getBlob")
            return result
        }
    }

    /**
     * Go to the specified row of the result set forwards or backwards by an offset relative to its current position.
     * A positive offset indicates moving backwards, and a negative offset indicates moving forwards.
     *
     * @param { Int32 } offset - Indicates the offset relative to the current position.
     * @returns { Bool } True if the result set is moved successfully and does not go beyond the range;
     * Returns false otherwise.
     * @throws { BusinessException } 14800000 - Inner error.
     * @throws { BusinessException } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException } 14800019 - The SQL must be a query statement.
     * @throws { BusinessException } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException } 14800029 - SQLite: The database is full.
     * @throws { BusinessException } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func goTo(offset: Int32): Bool {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGoTo(getID(), offset, inout errCode)
            throwIfNotSuccess(errCode, "ResultSet", "goTo")
            return result
        }
    }

    /**
     * Obtains the values of all columns in the specified row.
     * Inserting an empty blob, the obtained value is an empty blob.
     *
     * @returns { ValuesBucket } Indicates the row of data to be inserted into the table.
     * @throws { BusinessException  } 14800000 - Inner error.
     * @throws { BusinessException  } 14800011 - Failed to open the database because it is corrupted.
     * @throws { BusinessException  } 14800012 - ResultSet is empty or pointer index is out of bounds.
     * @throws { BusinessException  } 14800013 - Resultset is empty or column index is out of bounds.
     * @throws { BusinessException  } 14800014 - The RdbStore or ResultSet is already closed.
     * @throws { BusinessException  } 14800021 - SQLite: Generic error.
     * Possible causes: Insert failed or the updated data does not exist.
     * @throws { BusinessException  } 14800022 - SQLite: Callback routine requested an abort.
     * @throws { BusinessException  } 14800023 - SQLite: Access permission denied.
     * @throws { BusinessException  } 14800024 - SQLite: The database file is locked.
     * @throws { BusinessException  } 14800025 - SQLite: A table in the database is locked.
     * @throws { BusinessException  } 14800026 - SQLite: The database is out of memory.
     * @throws { BusinessException  } 14800027 - SQLite: Attempt to write a readonly database.
     * @throws { BusinessException  } 14800028 - SQLite: Some kind of disk I/O error occurred.
     * @throws { BusinessException  } 14800029 - SQLite: The database is full.
     * @throws { BusinessException  } 14800030 - SQLite: Unable to open the database file.
     * @throws { BusinessException  } 14800031 - SQLite: TEXT or BLOB exceeds size limit.
     * @throws { BusinessException  } 14800032 - SQLite: Abort due to constraint violation.
     * @throws { BusinessException  } 14800033 - SQLite: Data type mismatch.
     * @throws { BusinessException  } 14800034 - SQLite: Library used incorrectly.
     */
    @!APILevel[
        since: "22",
        syscap: "SystemCapability.DistributedDataManager.RelationalStore.Core",
        throwexception: true
    ]
    public func getRow(): ValuesBucket {
        unsafe {
            var errCode: Int32 = 0
            let result = FfiOHOSRelationalStoreGetRow(getID(), inout errCode)
            let map = convert(result)
            result.free()
            throwIfNotSuccess(errCode, "ResultSet", "getRow")
            return map
        }
    }
}
